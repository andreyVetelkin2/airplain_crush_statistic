# Переработка модели системной динамики

## Обзор изменений

Модель была полностью переработана согласно алгоритму решения систем ОДУ с внешними факторами и регрессиями.

## Основные улучшения

### 1. Структурированная архитектура

- **Функции внешних факторов** (`external_factors`): четко выделены F1-F5(t)
- **Функция правой части** (`deriv`): универсальная функция для solve_ivp и RK4
- **Вспомогательные функции**: полиномиальная интерполяция, обработка ограничений

### 2. Два метода интегрирования

#### Метод A: `solve_ivp` (scipy)
```python
t_values, X_values = model.solve_with_scipy(
    t_span=(0, 10),
    X0=X0,
    t_eval=t_eval,
    method='RK45'  # или 'Radau', 'BDF' для жестких систем
)
```

#### Метод B: Собственный RK4 с логированием
```python
t_values, X_values, rk4_log = model.runge_kutta_4(
    t_start=0,
    t_end=10,
    dt=0.1,
    X0=X0,
    log_rk4_steps=True  # сохраняет k1, k2, k3, k4 на каждом шаге
)
```

### 3. Логирование шагов RK4

При `log_rk4_steps=True` сохраняются все промежуточные коэффициенты:
- `k1 = h * f(tn, Xn)`
- `k2 = h * f(tn + h/2, Xn + k1/2)`
- `k3 = h * f(tn + h/2, Xn + k2/2)`
- `k4 = h * f(tn + h, Xn + k3)`

Это позволяет полностью аудировать процесс интегрирования.

### 4. Проверка сходимости

Автоматическая проверка сходимости путем сравнения решений с шагом `h` и `h/2`:

```python
converged, error_norm, results = model.check_convergence(
    t_span=(0, 10),
    h=0.1,
    tolerance=1e-3,
    method='rk4'
)
```

Вычисляется L2-норма разности решений. Если норма меньше порога - сходимость достигнута.

### 5. Экспорт результатов

#### CSV экспорт
```python
csv_path = model.export_to_csv(
    t_values, X_values,
    filename='results.csv',
    output_dir='output'
)
```

CSV содержит:
- Время (time)
- Все переменные (X1-X8)
- Все внешние факторы (F1-F5)

#### Графики
```python
plot_path = model.plot_results(
    t_values, X_values,
    filename='plots.png',
    output_dir='output',
    show_factors=True  # показывать графики F1-F5
)
```

Создает графики всех переменных и внешних факторов.

### 6. Обработка физических ограничений

- Автоматическое обрезание отрицательных значений: `X = max(X, 0.01)`
- Защита от численных артефактов в степенных функциях (X^0.53)
- Валидация результатов на каждом шаге

### 7. Универсальный метод `simulate()`

Обновленный метод `simulate()` поддерживает все новые возможности:

```python
results = model.simulate(
    years=10,
    dt=0.1,
    factor_multipliers={'F5': 1.5},  # сценарии "what-if"
    initial_conditions=X0,
    polynomial_coefs=poly_coefs,
    method='rk4',  # или 'scipy'
    log_rk4_steps=True,
    check_convergence=True,
    export_csv=True,
    export_plots=True,
    output_dir='output'
)
```

## Пример использования

Запустите скрипт `run_simulation.py`:

```bash
python run_simulation.py
```

Скрипт демонстрирует:
1. Базовую симуляцию с логированием RK4
2. Использование scipy (solve_ivp)
3. Сценарии "what-if" (изменение F5, начальных условий)
4. Проверку сходимости
5. Экспорт в CSV и графики

## Обратная совместимость

Старый API полностью сохранен:
- `system_equations()` - работает как раньше
- `runge_kutta_4()` - работает как раньше (но теперь возвращает также rk4_log)
- `simulate()` - работает как раньше, но с дополнительными опциями

## Математическая схема

### Система ОДУ (8 уравнений):

```
dX1/dt = F3(t) − (0.97 − 0.49·X2^0.53 + 0.10·X3^0.53 + 0.06·X4)
dX2/dt = (F1+F2+F4)·(0.75+0.08·X4)·(0.72+0.20·X6)·(0.97−0.20·X7) − (F3+F5)·(0.52+0.38·X8)
dX3/dt = F4·(0.78−0.37·X7) − (F3+F5)·(0.45+0.09·X1)
dX4/dt = F2·(0.55+0.17·X2)·(1.02−0.44·X7) − (F3+F5)·(0.66+0.05·X1)
dX5/dt = (0.45+0.48·X2) − F5
dX6/dt = F2·(1.18−0.47·X2) − F5
dX7/dt = F2·(1.37−0.77·X2)·(0.59+0.22·X3)·(1.24−0.71·X4) − (F3+F5)
dX8/dt = F5 − (0.87+0.02·X2)
```

### Внешние факторы (базовые):

```
F1(t) = 0.63 + 0.37·t
F2(t) = 1.00 − 0.23·t
F3(t) = 1.00 − 0.33·t
F4(t) = 0.51 + 0.46·t
F5(t) = 0.60 + 0.40·t
```

Или полиномиальные (если заданы коэффициенты):
```
F_i(t) = a·t³ + b·t² + c·t + d
```

## Рекомендации по использованию

1. **Для быстрых расчетов**: используйте `method='scipy'` с `RK45`
2. **Для полного контроля**: используйте `method='rk4'` с `log_rk4_steps=True`
3. **Для жестких систем**: используйте `method='scipy'` с `method='Radau'` или `'BDF'`
4. **Для проверки точности**: всегда включайте `check_convergence=True`
5. **Для анализа**: экспортируйте в CSV и стройте графики

## Зависимости

Добавлена зависимость:
- `pandas>=2.0.0` - для экспорта в CSV

Все остальные зависимости уже были в `requirements.txt`.

